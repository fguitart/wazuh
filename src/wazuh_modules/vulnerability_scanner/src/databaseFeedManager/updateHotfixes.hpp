/*
 * Wazuh storeRemediationsModel
 * Copyright (C) 2015, Wazuh Inc.
 * May 2, 2024.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _UPDATE_HOTFIXES_HPP
#define _UPDATE_HOTFIXES_HPP

#include "cve5_generated.h"
#include "flatbuffers/idl.h"
#include "hotfixes_applications_generated.h"
#include "hotfixes_applications_schema.h"
#include "loggerHelper.h"
#include "rocksDBWrapper.hpp"
#include "vulnerabilityScanner.hpp"
#include <unordered_set>

/**
 * @brief UpdateHotfixes class.
 *
 */
class UpdateHotfixes final
{
private:
    /**
     * @brief Get the list of hotfixes from the remediation data.
     *
     * @param remediations Pointer to the 'Remediations' object containing remediation information.
     * @return Set of strings containing the list of hotfixes.
     *
     * @see Remediations - The data structure containing remediation information.
     */
    static std::unordered_set<std::string> hotfixesOnRemediations(const cve_v5::Remediations* remediations)
    {
        std::unordered_set<std::string> hotfixes;
        if (!remediations || !remediations->windows())
        {
            return hotfixes;
        }

        std::for_each(remediations->windows()->begin(),
                      remediations->windows()->end(),
                      [&hotfixes](const cve_v5::Remediation* remediation)
                      {
                          if (!remediation->anyOf())
                          {
                              return;
                          }

                          for (const auto hotfix : *remediation->anyOf())
                          {
                              hotfixes.insert(hotfix->str());
                          }
                      });

        return hotfixes;
    }

public:
    /**
     * @brief Update the hotfix information in the RocksDB Database
     *
     * This function updates the hotfix information for a given vulnerability (CVE) in the RocksDB database.
     * It does so by inverting the relationship between the CVE and hotfix information,
     * going from 'CVE -> Hotfixes' to 'Hotfixes -> CVE'.
     *
     *
     * @param data Pointer to the 'Entry' object containing vulnerability and remediation information.
     * @param feedDatabase Pointer to the 'RocksDB' object for interacting with the database.
     *
     * @note The 'Entry' object should conform to the specified cve5 schema, including nested structures.
     * @note The 'RocksDBWrapper' object should be properly initialized and connected to the target database.
     *
     * @details The function performs the following steps:
     * 1. Attempts to access remediation data for Windows from the 'Entry' object.
     * 2. If remediation data is not available (empty), it logs an error message and returns.
     * 3. Extracts the CVE identifier (CVE-ID) from the 'Entry' object.
     * 4. Iterates through the available remediation data for Windows:
     *    - Extracts the list of updates (CVEs) associated with the hotfix.
     *    - Creates a FlatBuffers object containing the list of CVEs.
     *    - Serializes the FlatBuffers object into binary data.
     *    - Stores the binary data in the RocksDB database, using the 'hotfix' as the key.
     * 5. If an exception occurs during this process, it logs an error message.
     *
     * @note This function assumes a specific data structure in the 'Entry' object, including nested objects.
     *       Ensure that the 'Entry' object conforms to the expected schema to avoid runtime errors.
     *
     * @see Entry - The data structure containing CVE and remediation information.
     * @see RocksDBWrapper - The utility class for interacting with RocksDB databases.
     */
    static void storeVulnerabilityHotfixes(const cve_v5::Entry* data, Utils::IRocksDBWrapper* feedDatabase)
    {
        const auto remediations = data->containers()->cna()->x_remediations();
        if (!remediations)
        {
            return;
        }

        if (!feedDatabase->columnExists(HOTFIXES_APPLICATIONS_COLUMN))
        {
            feedDatabase->createColumn(HOTFIXES_APPLICATIONS_COLUMN);
        }

        flatbuffers::FlatBufferBuilder builder;
        const auto hotfixes = hotfixesOnRemediations(remediations);

        for (const auto& hotfix : hotfixes)
        {
            std::vector<flatbuffers::Offset<flatbuffers::String>> cvesVector;

            // Get the list of CVEs associated with the hotfix
            if (rocksdb::PinnableSlice hotfixesApplicationsSlice;
                feedDatabase->get(hotfix.c_str(), hotfixesApplicationsSlice, HOTFIXES_APPLICATIONS_COLUMN))
            {
                // Deserialize the binary data into a FlatBuffers object
                const auto hotfixesApplicationsData =
                    NSVulnerabilityScanner::GetHotfixesApplications(hotfixesApplicationsSlice.data());

                // Convert the binary data into a offset vector
                std::for_each(hotfixesApplicationsData->CVEs()->begin(),
                              hotfixesApplicationsData->CVEs()->end(),
                              [&builder, &cvesVector](const flatbuffers::String* cve)
                              { cvesVector.emplace_back(builder.CreateString(cve->str())); });
            }

            // Add the current CVE to the list of CVEs associated with the hotfix
            cvesVector.emplace_back(builder.CreateString(data->cveMetadata()->cveId()->str()));

            // Create a FlatBuffers object containing the list of CVEs
            const auto updates = builder.CreateVector(cvesVector);
            builder.Finish(NSVulnerabilityScanner::CreateHotfixesApplications(builder, updates));

            // Update the database with the new list of CVEs
            rocksdb::Slice newHotfixesApplications(reinterpret_cast<const char*>(builder.GetBufferPointer()),
                                                   builder.GetSize());
            feedDatabase->put(hotfix, newHotfixesApplications, HOTFIXES_APPLICATIONS_COLUMN);
        }
    }

    /**
     * @brief Deletes all hotfixes associated with a given vulnerability from the RocksDB database.
     *
     * @param data Pointer to the 'Entry' object containing vulnerability and remediation information.
     * @param feedDatabase rocksDB wrapper instance.
     */
    static void removeHotfix(const cve_v5::Entry* data, Utils::IRocksDBWrapper* feedDatabase)
    {
        if (!feedDatabase->columnExists(HOTFIXES_APPLICATIONS_COLUMN))
        {
            return;
        }

        const auto remediations = data->containers()->cna()->x_remediations();
        if (!remediations)
        {
            return;
        }

        const auto currentCVE = data->cveMetadata()->cveId()->str();
        const auto hotfixes = hotfixesOnRemediations(remediations);

        flatbuffers::FlatBufferBuilder builder;
        for (const auto& hotfix : hotfixes)
        {
            std::vector<flatbuffers::Offset<flatbuffers::String>> cvesVector;

            // Get the list of CVEs associated with the hotfix
            if (rocksdb::PinnableSlice hotfixesApplicationsSlice;
                feedDatabase->get(hotfix.c_str(), hotfixesApplicationsSlice, HOTFIXES_APPLICATIONS_COLUMN))
            {
                // Deserialize the binary data into a FlatBuffers object
                const auto hotfixesApplicationsData =
                    NSVulnerabilityScanner::GetHotfixesApplications(hotfixesApplicationsSlice.data());

                // Convert the binary data into a offset vector
                std::for_each(hotfixesApplicationsData->CVEs()->begin(),
                              hotfixesApplicationsData->CVEs()->end(),
                              [&builder, &cvesVector, &currentCVE](const flatbuffers::String* cve)
                              {
                                  if (cve->str() != currentCVE)
                                  {
                                      cvesVector.emplace_back(builder.CreateString(cve->str()));
                                  }
                              });
            }
            else
            {
                // If the hotfix is not in the database, skip it
                continue;
            }

            // If the list of CVEs is empty, delete whole entry
            if (cvesVector.empty())
            {
                feedDatabase->delete_(hotfix.c_str(), HOTFIXES_APPLICATIONS_COLUMN);
                continue;
            }

            // Create a FlatBuffers object containing the remaining CVEs
            const auto updates = builder.CreateVector(cvesVector);
            builder.Finish(NSVulnerabilityScanner::CreateHotfixesApplications(builder, updates));

            // Update the database with the new list of CVEs
            rocksdb::Slice newHotfixesApplications(reinterpret_cast<const char*>(builder.GetBufferPointer()),
                                                   builder.GetSize());
            feedDatabase->put(hotfix, newHotfixesApplications, HOTFIXES_APPLICATIONS_COLUMN);
        }
    }
};

#endif // _UPDATE_HOTFIXES_HPP
