/*
 * Wazuh storeRemediationsModel
 * Copyright (C) 2015, Wazuh Inc.
 * October 05, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _UPDATE_HOTFIXES_HPP
#define _UPDATE_HOTFIXES_HPP

#include "cve5_generated.h"
#include "hotfixes_generated.h"
#include "hotfixes_schema.h"
#include "loggerHelper.h"
#include "rocksDBWrapper.hpp"
#include "vulnerabilityScanner.hpp"
#include <unordered_set>

/**
 * @brief UpdateHotfixes class.
 *
 */
class UpdateHotfixes final
{
private:
    /**
     * @brief Get the list of hotfixes from the remediation data.
     *
     * @param remediations Pointer to the 'Remediations' object containing remediation information.
     * @return Set of strings containing the list of hotfixes.
     *
     * @see Remediations - The data structure containing remediation information.
     */
    static std::unordered_set<std::string> hotfixesOnRemediations(const cve_v5::Remediations* remediations)
    {
        std::unordered_set<std::string> hotfixes;
        if (!remediations)
        {
            return hotfixes;
        }

        std::for_each(remediations->windows()->begin(),
                      remediations->windows()->end(),
                      [&hotfixes](const cve_v5::Remediation* remediation)
                      {
                          for (const auto& hotfix : *remediation->anyOf())
                          {
                              hotfixes.insert(hotfix->str());
                          }
                      });

        return hotfixes;
    }

public:
    /**
     * @brief Update the hotfix information in the RocksDB Database
     *
     * This function updates the hotfix information for a given vulnerability (CVE) in the RocksDB database.
     * It does so by inverting the relationship between the CVE and hotfix information,
     * going from 'CVE -> Hotfixes' to 'Hotfixes -> CVE'.
     *
     *
     * @param data Pointer to the 'Entry' object containing vulnerability and remediation information.
     * @param feedDatabase Pointer to the 'RocksDB' object for interacting with the database.
     *
     * @note The 'Entry' object should conform to the specified cve5 schema, including nested structures.
     * @note The 'RocksDBWrapper' object should be properly initialized and connected to the target database.
     *
     * @details The function performs the following steps:
     * 1. Attempts to access remediation data for Windows from the 'Entry' object.
     * 2. If remediation data is not available (empty), it logs an error message and returns.
     * 3. Extracts the CVE identifier (CVE-ID) from the 'Entry' object.
     * 4. Iterates through the available remediation data for Windows:
     *    - Extracts the list of updates (CVEs) associated with the remediation.
     *    - Creates a FlatBuffers object containing the list of CVEs.
     *    - Serializes the FlatBuffers object into binary data.
     *    - Stores the binary data in the RocksDB database, using the Remediation as the key.
     * 5. If an exception occurs during this process, it logs an error message.
     *
     * @note This function assumes a specific data structure in the 'Entry' object, including nested objects.
     *       Ensure that the 'Entry' object conforms to the expected schema to avoid runtime errors.
     *
     * @see Entry - The data structure containing CVE and remediation information.
     * @see RocksDBWrapper - The utility class for interacting with RocksDB databases.
     */
    static void storeVulnerabilityHotfixes(const cve_v5::Entry* data, Utils::IRocksDBWrapper* feedDatabase)
    {
        if (!data->containers()->cna() && !data->containers()->cna()->x_remediations())
        {
            return;
        }

        const auto remediations = data->containers()->cna()->x_remediations();

        if (!remediations)
        {
            logError(WM_VULNSCAN_LOGTAG, "No remediations available.");
            return;
        }

        flatbuffers::Parser parser;
        if (!parser.Parse(vulnerabilityRemediations_SCHEMA))
        {
            throw std::runtime_error("Unable to parse schema: " + parser.error_);
        }

        const auto currentCVE {data->cveMetadata()->cveId()->str()}; // CVE associated with the current remediations
        rocksdb::PinnableSlice cveList;

        // 1. Get the CVEs list associated with each remediation from the database
        // 2. Convert the list back into a JSON object
        // 3. Add the current CVE to the list
        // 4. Convert the JSON object back into a FlatBuffer object
        // 5. Update the remediation with the new CVE list
        for (const auto& hotfix : hotfixesOnRemediations(remediations))
        {
            nlohmann::json jsonData;

            if (feedDatabase->get(hotfix, cveList, REMEDIATIONS_COLUMN))
            {
                // There is already a list of CVEs associated with the hotfix
                std::string strData;
                flatbuffers::GenText(parser, reinterpret_cast<const uint8_t*>(cveList.data()), &strData);
                jsonData = nlohmann::json::parse(strData);
            }

            jsonData.push_back(currentCVE);

            if (!parser.Parse(jsonData.dump().c_str()))
            {
                throw std::runtime_error("Unable to parse patched data: " + parser.error_);
            }

            flatbuffers::FlatBufferBuilder builder;
            rocksdb::Slice flatbufferData(reinterpret_cast<const char*>(parser.builder_.GetBufferPointer()),
                                          parser.builder_.GetSize());

            // Update the remediation with the new CVE list
            if (!feedDatabase->columnExists(HOTFIXES_COLUMN))
            {
                feedDatabase->createColumn(HOTFIXES_COLUMN);
            }
            feedDatabase->put(hotfix, flatbufferData, HOTFIXES_COLUMN);
        }
    }

    /**
     * @brief Deletes a hotfix from the database
     *
     * @param hotfix Hotfix to be removed.
     * @param feedDatabase rocksDB wrapper instance.
     */
    static void removeHotfix(const std::string& hotfix, Utils::IRocksDBWrapper* feedDatabase)
    {
        if (hotfix.empty())
        {
            return;
        }

        if (!feedDatabase->columnExists(HOTFIXES_COLUMN))
        {
            return;
        }

        feedDatabase->delete_(hotfix, HOTFIXES_COLUMN);
    }
};

#endif // _UPDATE_HOTFIXES_HPP
