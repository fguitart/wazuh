/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * May 2, 2024.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _REMEDIATION_DATA_CACHE_HPP
#define _REMEDIATION_DATA_CACHE_HPP

#include "../policyManager/policyManager.hpp"
#include "cacheLRU.hpp"
#include "singleton.hpp"
#include "socketDBWrapper.hpp"
#include "wazuhDBQueryBuilder.hpp"
#include "wdbDataException.hpp"
#include <shared_mutex>
#include <string>
#include <unordered_set>

namespace RemediationDataCacheConstants
{
    auto constexpr WDB_SOCKET {"queue/db/wdb"};
}

/**
 * @brief Remediation structure.
 */
struct Remediation final
{
    std::unordered_set<std::string> hotfixes; ///< Installed hotfixes.
};

/**
 * @brief remediationDataCache class.
 *
 * @note This class queries the Wazuh-DB to get the remediation data for a given agent, and stores it in a LRU cache
 */
class remediationDataCache final : public Singleton<remediationDataCache>
{
private:
    LRUCache<std::string, Remediation> m_remediationData {PolicyManager::instance().getRemediationLRUSize()};
    std::shared_mutex m_mutex;
    std::optional<SocketDBWrapper> m_wdbSocketWrapper {std::nullopt};

    Remediation getRemediationDataFromWdb(const std::string& agentId)
    {
        nlohmann::json response;
        try
        {
            m_wdbSocketWrapper->query(WazuhDBQueryBuilder::builder().agentGetHotfixesCommand(agentId).build(),
                                      response);
        }
        catch (const std::exception& e)
        {
            throw WdbDataException(e.what(), agentId);
        }

        if (response.empty())
        {
            throw WdbDataException("Empty response from Wazuh-DB", agentId);
        }

        Remediation remediationData;

        // Iterate over the response and store the hotfixes.
        for (auto& hotfix : response)
        {
            remediationData.hotfixes.insert(hotfix.at("hotfix"));
        }

        return remediationData;
    }

public:
    /**
     * @brief This method returns the Remediation data.
     * @param agentId agent id.
     *
     * @return Remediation
     */
    Remediation getRemediationData(const std::string& agentId)
    {
        std::shared_lock lock(m_mutex);
        if (auto value = m_remediationData.getValue(agentId); value)
        {
            return *value;
        }

        if (!m_wdbSocketWrapper)
        {
            try
            {
                m_wdbSocketWrapper.emplace(RemediationDataCacheConstants::WDB_SOCKET);
            }
            catch (...)
            {
                throw WdbDataException("Error creating socketDBWrapper", agentId);
            }
        }

        const auto remediationData = getRemediationDataFromWdb(agentId);
        m_remediationData.insertKey(agentId, remediationData); // Update the cache with the queried data.

        return remediationData;
    }

    /**
     * @brief Add remediation data to the cache.
     *
     * @note If the agentId already exists in the cache, the new data is merged with the existing data.
     *
     * @param agentId agent id.
     * @param newRemediationData data to be inserted.
     */
    void addRemediationData(const std::string& agentId, Remediation newRemediationData)
    {
        std::scoped_lock lock(m_mutex);

        // Merge the new data with the current data.
        if (auto currentData = m_remediationData.getValue(agentId); currentData.has_value())
        {
            newRemediationData.hotfixes.insert(currentData->hotfixes.begin(), currentData->hotfixes.end());
        }

        m_remediationData.insertKey(agentId, newRemediationData);
    }
};
#endif // _REMEDIATION_DATA_CACHE_HPP
