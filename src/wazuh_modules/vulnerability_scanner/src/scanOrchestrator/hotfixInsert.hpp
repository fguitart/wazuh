/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * May 2, 2024.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _HOTFIX_INSERT_HPP
#define _HOTFIX_INSERT_HPP

#include "chainOfResponsability.hpp"
#include "databaseFeedManager.hpp"
#include "hotfix_generated.h"
#include "hotfix_schema.h"
#include "inventorySync.hpp"
#include "remediationDataCache.hpp"
#include "scanContext.hpp"

/**
 * @brief TEventInsertInventory class.
 * This class is in charge of inserting the inventory entries for a given agent and affected component type.
 * It receives the scan context and the inventory database and returns the scan context with the inventory updated.
 * The affected component type can be Os or Package.
 * Os: Insert inventory of the OS for the agent.
 * Package: Insert a package into the inventory for the agent.
 *
 * @tparam TScanContext scan context type.
 */
template<typename TDatabaseFeedManager = DatabaseFeedManager, typename TScanContext = ScanContext>
class THotfixInsert final : public AbstractHandler<std::shared_ptr<TScanContext>>
{
private:
    std::shared_ptr<TDatabaseFeedManager> m_databaseFeedManager;

public:
    // LCOV_EXCL_START
    /**
     * @brief HotfixInsert event constructor.
     *
     * @param databaseFeedManager Database feed manager.
     */
    explicit THotfixInsert(std::shared_ptr<TDatabaseFeedManager>& databaseFeedManager)
        : m_databaseFeedManager(databaseFeedManager)
    {
    }
    // LCOV_EXCL_STOP

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param data Scan context.
     * @return std::shared_ptr<ScanContext> Abstract handler.
     */
    std::shared_ptr<TScanContext> handleRequest(std::shared_ptr<TScanContext> data) override
    {
        logDebug2(WM_VULNSCAN_LOGTAG, "Inserting inventory entries for the installed hotfixes");
        FlatbufferDataPair<NSVulnerabilityScanner::hotfix> hotfixVulnerabilities;

        // Get the list of CVEs remediated by the installed hotfixes
        const std::string hotfixId {data->hotfixId()};
        m_databaseFeedManager->getHotfixVulnerabilities(hotfixId, hotfixVulnerabilities);

        if (hotfixVulnerabilities.data == nullptr || hotfixVulnerabilities.data->CVEs() == nullptr ||
            hotfixVulnerabilities.data->CVEs()->size() == 0)
        {
            logDebug2(WM_VULNSCAN_LOGTAG, "No CVEs associated for the installed hotfix (%s)", hotfixId);
        }
        else
        {
            // For each CVE, insert the inventory entry
            for (const auto& cve : *hotfixVulnerabilities.data->CVEs())
            {
                // Add all CVEs to the deletetion list
                logDebug2(WM_VULNSCAN_LOGTAG, "CVE '%s' was remediated by hotfix '%s'", cve->str().c_str(), hotfixId);
                data->m_elements[cve->str()] = nlohmann::json::object();
            }
        }

        return AbstractHandler<std::shared_ptr<TScanContext>>::handleRequest(std::move(data));
    }
};

using HotfixInsert = THotfixInsert<>;

#endif // _HOTFIX_INSERT_HPP
