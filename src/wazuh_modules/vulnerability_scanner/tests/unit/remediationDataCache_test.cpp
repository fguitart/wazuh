/*
 * Wazuh Vulnerability Scanner - Unit Tests
 * Copyright (C) 2015, Wazuh Inc.
 * May 2, 2024.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "remediationDataCache_test.hpp"

bool hotfixesAreEqual(const Remediation& remediation1, const Remediation& remediation2)
{
    if (remediation1.hotfixes.size() != remediation2.hotfixes.size())
    {
        return false;
    }

    for (const auto& hotfix : remediation1.hotfixes)
    {
        if (remediation2.hotfixes.find(hotfix) == remediation2.hotfixes.end())
        {
            return false;
        }
    }

    return true;
}

TEST_F(remediationDataCacheTest, InsertMultipleItems)
{
    remediationDataCache cache;
    std::string agentId {"1"};

    { 
        // Set value in cache
        Remediation remediationData {
            .hotfixes = {"hotfix1", "hotfix2"},
        };

        cache.addRemediationData(agentId, remediationData);

        // Get value from cache
        const auto retrievedData = cache.getRemediationData(agentId);

        // Verify that the returned value is the same as the one set
        EXPECT_TRUE(hotfixesAreEqual(remediationData, remediationData));
    }

    {
        // Set another value in cache
        Remediation remediationData {
            .hotfixes = {"hotfix3", "hotfix4"},
        };

        cache.addRemediationData(agentId, remediationData);

        // Get value from cache
        const auto retrievedData = cache.getRemediationData(agentId);

        // Verify that the returned value is equal to both the values set
        Remediation expected {.hotfixes = {"hotfix1", "hotfix2", "hotfix3", "hotfix4"}};
        EXPECT_TRUE(hotfixesAreEqual(retrievedData, expected));
    }
}

TEST_F(remediationDataCacheTest, SetAndGetSuccess)
{
    // Start fake server
    m_socketServer->listen(
        [&](const int fd, const char* data, uint32_t size, const char* dataHeader, uint32_t sizeHeader)
        {
            std::ignore = fd;
            std::ignore = dataHeader;
            std::ignore = sizeHeader;
            std::ignore = size;
            std::ignore = data;

            m_socketServer->send(fd, "err ", 4);
        });

    remediationDataCache cache;
    std::string agentId {"1"};

    // Try to get value from empty cache
    EXPECT_THROW(cache.getRemediationData(agentId), WdbDataException);

    // Set value in cache
    Remediation remediationData {
        .hotfixes = {"hotfix1", "hotfix2"},
    };

    cache.addRemediationData(agentId, remediationData);

    // Get value from cache
    const auto retrievedData = cache.getRemediationData(agentId);

    // Verify that the returned value is the same as the one set
    EXPECT_TRUE(hotfixesAreEqual(remediationData, retrievedData));

    // Try to get from non existing agent
    EXPECT_THROW(cache.getRemediationData("2"), WdbDataException);
}
